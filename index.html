<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CPU Load Monitor</title>
    <style>
        body {
            background-color: #16273f;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            border: 1px solid #16273f;
            background-color: #16273f;
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <canvas id="cpuCanvas"></canvas>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const socket = new WebSocket('ws://' + window.location.host + '/ws');
            const canvas = document.getElementById('cpuCanvas');
            const ctx = canvas.getContext('2d');
            let rectSize = %d;
            const origHistoryLength = %d;
            let numDataRows = %d;
            let historyLength = Math.min(Math.round(window.innerHeight / rectSize), origHistoryLength);
            let timeWidth = rectSize * 9;
            let dataInterval = %d;
            let history = [];
            let isPaused = false;
            let scrollOffset = 0;
            let animationFrameId;
            let lastUpdateTime = performance.now();
            let dataQueue = [];
            let lastDataTimestamp = performance.now();
            let maxFPS = 60;
            let targetFPS = 50;
            let minFPS = 30;
            let neverUpdatedFromFetchHistory = true;
            let dataLate = false;
            let scrollSpeed = 1;
            console.log('window.innerHeight:', window.innerHeight);
            console.log('historyLength:', historyLength);
            const offScreenCanvas = document.createElement('canvas');
            const offScreenCtx = offScreenCanvas.getContext('2d');

            canvas.height = origHistoryLength * rectSize - rectSize;

            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('rectSize')) {
                rectSize = parseInt(urlParams.get('rectSize'));
                console.log('rectSize:', rectSize);
            }
            if (urlParams.has('historyLength')) {
                historyLength = parseInt(urlParams.get('historyLength'));
            }
            if (urlParams.has('dataInterval')) {
                dataInterval = parseInt(urlParams.get('dataInterval'));
            }

            function fetchHistory() {
                return fetch('/history')
                    .then(response => response.text())
                    .then(data => {
                        history = [];
                        const rows = data.split('\n').reverse();
                        rows.forEach(row => {
                            row = row.trim();
                            if (row) {
                                history.unshift(row.split(','));
                            }
                        });
                        if (history.length > historyLength) {
                            history = history.slice(0, historyLength);
                        }
                        updateCanvasDimensions();
                    })
                    .catch(error => {
                        console.error('Fetching history failed:', error);
                    });
            }

            function updateCanvasDimensions() {
                let newHeight = origHistoryLength * rectSize - rectSize;
                if (canvas.height !== newHeight) {
                    canvas.height = newHeight;
                }
                let newOffScreenHeight = historyLength * rectSize - rectSize;
                if (offScreenCanvas.height !== newOffScreenHeight) {
                    offScreenCanvas.height = newOffScreenHeight;
                }
                let newWidth = numDataRows * rectSize + timeWidth;
                if (canvas.width !== newWidth) {
                    canvas.width = newWidth;
                    offScreenCanvas.width = canvas.width;
                }
            }

            function getFlameColor(percentage) {
                if (percentage <= 5) {
                    return 'rgb(0,0,0)';
                } else if (percentage <= 20) {
                    return 'rgb(50,20,0)';
                } else if (percentage <= 40) {
                    return 'rgb(139,0,0)';
                } else if (percentage <= 60) {
                    return 'rgb(255,69,0)';
                } else if (percentage <= 80) {
                    return 'rgb(255,140,0)';
                } else if (percentage <= 95) {
                    return 'rgb(255,255,0)';
                } else {
                    return 'rgb(255,255,255)';
                }
            }

            function draw() {
                if (history.length === 0) return;

                const redrawStartTime = performance.now();
                const elapsed = redrawStartTime - lastUpdateTime;
                lastUpdateTime = redrawStartTime;

                scrollOffset += (scrollSpeed * elapsed);

                while (scrollOffset >= rectSize) {
                    scrollOffset -= rectSize;
                    if (dataQueue.length === 0) {
                        history.unshift(history[0]);
                    } else {
                        const newData = dataQueue.shift();
                        history.unshift(newData);
                    }
                }

                offScreenCtx.clearRect(0, 0, offScreenCanvas.width, offScreenCanvas.height);
                offScreenCtx.font = `${rectSize}px monospace`;

                const displayedHistory = history.slice(0, historyLength);

                offScreenCtx.save();
                offScreenCtx.translate(0, Math.floor(scrollOffset));

                displayedHistory.forEach((data, row) => {
                    let coreIndex = 0;
                    const yOffset = Math.floor(row * rectSize);

                    if (yOffset + rectSize <= 0 || yOffset >= canvas.height) {
                        return;
                    }

                    data.forEach((value, col) => {
                        offScreenCtx.fillStyle = '#FFFFFF';
                        if (col === 0) {
                            if (timeWidth == 0) return;
                            const x = 2;
                            const y = Math.floor(yOffset + rectSize - 2);
                            if (value) {
                                offScreenCtx.fillText(value.padEnd(12, '0'), x, y);
                            }
                        } else if (col === 1) {
                            return;
                        } else {
                            if (value === "" || value === "|") {
                                coreIndex++;
                                return;
                            }
                            const x = Math.floor(coreIndex * rectSize + timeWidth);
                            const y = Math.floor(yOffset);
                            let color = getFlameColor(parseFloat(value));
                            offScreenCtx.fillStyle = color;
                            offScreenCtx.fillRect(x, y, rectSize, rectSize);
                            coreIndex++;
                        }
                    });
                });

                offScreenCtx.restore();
                offScreenCtx.clearRect(0, 0, offScreenCanvas.width, rectSize);
                offScreenCtx.clearRect(0, offScreenCanvas.height - rectSize, offScreenCanvas.width, offScreenCanvas.height);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(offScreenCanvas, 0, 0);

                if (!isPaused) {
                    animationFrameId = requestAnimationFrame(draw);
                }
            }

            function adjustFrameRate() {
                const frameTime = 1000 / targetFPS;
                const actualFrameTime = performance.now() - lastUpdateTime;
                if (actualFrameTime > frameTime) {
                    targetFPS = Math.max(minFPS, targetFPS - 1);
                    if (targetFPS <= minFPS) {
                        if (history != null && history.length < historyLength) {
                            historyLength = history.length;
                        }
                        historyLength = Math.max(Math.min(origHistoryLength, 15), historyLength - 5);
                        historyLength = Math.min(Math.round(window.innerHeight / rectSize), historyLength);
                        if (historyLength < origHistoryLength)
                            updateCanvasDimensions();
                    }
                    console.log(`Reducing workload, FPS to: ${targetFPS}, history length to: ${historyLength}`);
                } else if (targetFPS < maxFPS && actualFrameTime < frameTime * 0.2) {
                    if (historyLength < Math.round(window.innerHeight / rectSize)) {
                        historyLength = Math.min(origHistoryLength, historyLength + 5);
                        historyLength = Math.min(Math.round(window.innerHeight / rectSize), historyLength);
                        updateCanvasDimensions();
                    } else {
                        targetFPS = Math.min(maxFPS, targetFPS + 2);
                    }
                    console.log(`Increasing workload, FPS to: ${targetFPS}, history length to: ${historyLength}`);
                }
                setTimeout(adjustFrameRate, frameTime);
            }

            function handleVisibilityChange() {
                if (document.visibilityState === 'visible') {
                    fetchHistory().then(() => {
                        lastUpdateTime = performance.now();
                        scrollOffset = 0;
                        if (!isPaused) {
                            animationFrameId = requestAnimationFrame(draw);
                        }
                    });
                } else {
                    cancelAnimationFrame(animationFrameId);
                }
            }

            function togglePause() {
                isPaused = !isPaused;
                console.log("Paused:", isPaused);
                if (!isPaused) {
                    fetchHistory().then(() => {
                        lastUpdateTime = performance.now();
                        scrollOffset = 0;
                        animationFrameId = requestAnimationFrame(draw);
                    });
                } else {
                    cancelAnimationFrame(animationFrameId);
                }
            }

            function clearDataQueuePeriodically() {
                setInterval(() => {
                    if (dataQueue.length > historyLength) {
                        dataQueue = dataQueue.slice(-historyLength);
                    }
                }, 5000);
            }

            function adjustRectSize() {
                if (rectSize < 1) {
                    rectSize = 1;
                }
                if (rectSize > 25) {
                    rectSize = 25;
                }
                console.log('new rectSize:', rectSize);
                timeWidth = rectSize * 9;
                if (rectSize <= 5) {
                    timeWidth = 0;
                }
                scrollSpeed = rectSize / dataInterval;
                updateCanvasDimensions();
            }

            function adjustRectSizeEvent(event) {
                if (event.deltaY < 0) {
                    if (rectSize <= 25)
                        rectSize += 1;
                } else {
                    if (rectSize >= 1)
                        rectSize -= 1;
                }
                adjustRectSize();
            }

            document.onwheel = adjustRectSizeEvent;

            canvas.addEventListener("click", togglePause);
            document.addEventListener("visibilitychange", handleVisibilityChange);

            fetchHistory().then(() => {
                animationFrameId = requestAnimationFrame(draw);
            });
            clearDataQueuePeriodically();
            adjustRectSize();
            updateCanvasDimensions();
            adjustFrameRate();

            socket.onopen = function() {
                console.log('WebSocket connection opened.');
            };

            socket.onmessage = function(event) {
                if (isPaused) return;

                const data = event.data.split(",");
                if (data.length > 0) {
                    dataQueue.push(data); // Add new data at the end of the queue
                    lastDataTimestamp = performance.now();
                }
            };

            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
            };

            socket.onclose = function() {
                console.log('WebSocket connection closed.');
            };
        });
    </script>
</body>
</html>
